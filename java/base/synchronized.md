### synchronized  
synchronized用于资源进行加锁，以保证同一时间只有一个线程可以访问这个资源。

#### 使用层面的synchronized
使用java开发你都无法避免会使用synchronized关键字，而在真正使用中我们需要了解一些规则。  

##### 用synchronized修饰的资源类型来进行区分：
###### 1，修饰方法的用法
```JAVA
public synchronized void funa（）{
    //互斥代码
}
public synchronized void funb（）{
    //互斥代码
}
```
这个是锁执行这个方法的对象。这么说理解起来也比较方便，就是我们把这个对象给锁了，那么要来获取这个锁的都是互斥的，funa和funb用同个对象不能并发执行。

###### 2，修饰this
```JAVA
synchronized（this）{
    //骄傲的代码
}
```
this是这个调用的对象，那就和第一种是一个情况了，大家都是在锁一个东西所以这个代码块的执行也是和第一种情况的方法是互斥的

###### 3，修饰calss
```JAVA
synchronized（Book.calss）{
    //骄傲的代码
}
```
编译器会在依据.class文件生成Class对象，并加载到内存中，Class对象存储着类文件的信息。事实上，创建对象实例是依据内存中的Class对象的。  
不过说到底还是对象，只是和实例对象为不同对象。既然不同，那么也就是说锁的东西不一样，所以修饰class这种情况的和第一和第二中情况都是不互斥的，是可以并发执行的。

###### 4，修饰static方法
```JAVA
public static synchronized void fun(){
    //骄傲的代码
}
```
static的方法属于类方法，属于第三种情况中提到的类对象的方法，所以它锁的是类对象。

###### 5，修饰私有object
```JAVA
synchronized（object）{
    //互斥代码
}
```
这种是比较常用的代码，单独出一个对象作为锁对象。

至此基本了解打多数使用写法，其实就是看锁的对象到底是什么，就可以判断是否执行互斥。

#### 底层实现层面
Synchronized的语义底层是通过一个monitor的对象来完成,每一个对象都关联着一个monitor，反编译后看到的指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。

##### 优化
监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的，传说操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。
而优化的地方就是减少不必要的切换。据说有团队进行过调研，在实际场景中使用synchronized修饰的代码实际能够出现多线程竞争的场景可能只是一小部分情况，还有一些情况是：  
1:一段时间里始终为一个相同的线程在进入同步代码；  
2，一个线程执行完毕后，另一个线程进入同步代码。  
对于这些并不需要Mutex Lock情况可以进行优化。 优化的方式是将这个事情的状态细分化：  
锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。  
###### 偏向锁
偏向锁是在只有一个线程执行同步块时提高性能。  
偏向锁获取过程：  
　　（1）访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01——确认为可偏向状态。  
　　（2）如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。  
　　（3）如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果竞争失败，执行（4）。  
　　（4）如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。  
　　（5）执行同步代码。

如果没有竞争的情况下只需要判断标示和一个线程ID即可。  
 偏向锁的释放：
　　偏向锁的撤销在上述第四步骤中有提到。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。

###### 轻量级锁  
轻量级锁是为了在线程交替执行同步块时提高性能。  
轻量级锁的加锁过程：
  （1）在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。这时候线程堆栈与对象头的状态如图2.1所示。  
　　（2）拷贝对象头中的Mark Word复制到锁记录中。  
　　（3）拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤（3），否则执行步骤（4）。  
　　（4）如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，这时候线程堆栈与对象头的状态如图2.2所示。  
　　（5）如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。

轻量级锁的解锁过程：  
　　（1）通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。  
　　（2）如果替换成功，整个同步过程就完成了。  
　　（3）如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。  
